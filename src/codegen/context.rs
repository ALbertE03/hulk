use crate::semantic::Context as SemanticContext;
use std::collections::HashMap;
use super::utils::{escape_llvm, ValTy};

/// Información completa del layout de una clase, incluyendo atributos/métodos heredados.
#[allow(dead_code)]
pub struct ClassLayout {
    pub struct_name: String,                    // %T.MiClase
    pub type_id: u32,                           // id entero único para is/as
    /// Todos los atributos (padre primero, luego propios), nombre -> (índice, clase dueña)
    pub attr_indices: HashMap<String, u32>,
    /// Lista ordenada de nombres de atributos (para iteración)
    pub attr_order: Vec<String>,
    /// nombre_método -> @NombreClase_método  (incluye heredados)
    pub method_names: HashMap<String, String>,
    /// nombre de la clase padre (si existe)
    pub parent_name: Option<String>,
    pub total_fields: u32,                      // incluyendo type-id en slot 0
    /// Nombre de atributo -> nombre de tipo declarado (ej. "String", "Number", "Boolean")
    pub attr_types: HashMap<String, String>,
    /// nombre_método -> tipo de retorno ("Number", "String", "Boolean", o nombre de clase)
    pub method_ret_types: HashMap<String, String>,
}

pub struct Ctx<'a> {
    pub preamble: String,
    pub globals: String,
    pub functions: String,
    pub counter: usize,
    pub scopes: Vec<HashMap<String, (String, ValTy)>>, // nombre -> (ptr, tipo)
    pub classes: HashMap<String, ClassLayout>,
    pub current_class: Option<String>,
    #[allow(dead_code)]
    pub sem: &'a SemanticContext,
    /// Siguiente type-id para registro de clases
    pub next_type_id: u32,
    /// Definiciones de funciones lambda diferidas (emitidas fuera de la función actual)
    pub lambda_defs: String,
    /// Tipos de retorno de funciones con nombre
    pub func_ret_types: HashMap<String, ValTy>,
    /// Mapeo de protocolos a tipos que los implementan: protocolo -> vec[(type_id, clase)]
    pub protocol_implementations: HashMap<String, Vec<(u32, String)>>,
    /// Wrappers de functors generados automáticamente: función_nombre -> (protocolo, wrapper_type_name)
    pub auto_functor_wrappers: HashMap<String, (String, String)>,
}

impl<'a> Ctx<'a> {
    pub fn new(sem: &'a SemanticContext) -> Self {
        let preamble = "\
; HULK -> LLVM IR  (generated by Albert XD )\n\
declare i32 @printf(i8*, ...)\n\
declare i32 @puts(i8*)\n\
declare i8* @malloc(i64)\n\
declare i8* @realloc(i8*, i64)\n\
declare void @free(i8*)\n\
declare i64 @strlen(i8*)\n\
declare i8* @strcpy(i8*, i8*)\n\
declare i8* @strcat(i8*, i8*)\n\
declare i32 @snprintf(i8*, i64, i8*, ...)\n\
declare i32 @rand()\n\
declare void @srand(i32)\n\
declare i64 @time(i64*)\n\
declare void @abort()\n\
declare double @llvm.pow.f64(double, double)\n\
declare double @llvm.sin.f64(double)\n\
declare double @llvm.cos.f64(double)\n\
declare double @llvm.exp.f64(double)\n\
declare double @llvm.log.f64(double)\n\
declare double @llvm.sqrt.f64(double)\n\
declare double @llvm.fabs.f64(double)\n\
declare double @llvm.floor.f64(double)\n\
\n\
@.fmt_int  = private unnamed_addr constant [5 x i8] c\"%.0f\\00\"\n\
@.fmt_num  = private unnamed_addr constant [5 x i8] c\"%.6g\\00\"\n\
@.fmt_str  = private unnamed_addr constant [3 x i8] c\"%s\\00\"\n\
@.fmt_nl   = private unnamed_addr constant [2 x i8] c\"\\0A\\00\"\n\
@.true_s   = private unnamed_addr constant [5 x i8] c\"true\\00\"\n\
@.false_s  = private unnamed_addr constant [6 x i8] c\"false\\00\"\n\
@.space_s  = private unnamed_addr constant [2 x i8] c\" \\00\"\n\
@.empty_s  = private unnamed_addr constant [1 x i8] c\"\\00\"\n\
@.vec_open = private unnamed_addr constant [2 x i8] c\"[\\00\"\n\
@.vec_close = private unnamed_addr constant [2 x i8] c\"]\\00\"\n\
@.vec_sep  = private unnamed_addr constant [3 x i8] c\", \\00\"\n\
@.oob_msg  = private unnamed_addr constant [36 x i8] c\"Runtime error: index out of bounds\\0A\\00\"\n\
@.rand_seeded = global i1 false\n\
".to_string();

        Ctx {
            preamble,
            globals: String::new(),
            functions: String::new(),
            counter: 0,
            scopes: vec![HashMap::new()],
            classes: HashMap::new(),
            current_class: None,
            sem,
            next_type_id: 1, // 0 = reservado / desconocido
            lambda_defs: String::new(),
            func_ret_types: HashMap::new(),
            protocol_implementations: HashMap::new(),
            auto_functor_wrappers: HashMap::new(),
        }
    }

    // auxiliares 
    pub fn tmp(&mut self) -> String { let n = format!("%t{}", self.counter); self.counter += 1; n }
    pub fn lbl(&mut self, pfx: &str) -> String { let n = format!("{}_{}", pfx, self.counter); self.counter += 1; n }
    pub fn emit(&mut self, s: &str) { self.functions.push_str("  "); self.functions.push_str(s); self.functions.push('\n'); }
    pub fn emit_label(&mut self, l: &str) { self.functions.push_str(l); self.functions.push_str(":\n"); }

    pub fn add_global_string(&mut self, value: &str) -> String {
        let id = format!("@.slit_{}", self.counter);
        self.counter += 1;
        let len = value.len() + 1;
        self.globals.push_str(&format!(
            "{} = private unnamed_addr constant [{} x i8] c\"{}\\00\"\n", id, len, escape_llvm(value)
        ));
        id
    }

    pub fn gep_string(&self, id: &str, len: usize) -> String {
        format!("getelementptr inbounds ([{} x i8], [{} x i8]* {}, i64 0, i64 0)", len, len, id)
    }

    pub fn enter_scope(&mut self) { self.scopes.push(HashMap::new()); }
    pub fn exit_scope(&mut self)  { self.scopes.pop(); }

    pub fn def_var(&mut self, name: &str, ptr: &str, ty: ValTy) {
        if let Some(s) = self.scopes.last_mut() {
            s.insert(name.to_string(), (ptr.to_string(), ty));
        }
    }
    
    pub fn get_var(&self, name: &str) -> Option<(String, ValTy)> {
        for s in self.scopes.iter().rev() {
            if let Some(v) = s.get(name) { return Some(v.clone()); }
        }
        None
    }

    /// Convierte de forma segura un valor `double` (puntero codificado como double) a un puntero tipado.
    /// Derrama el i64 a través de un alloca en la pila para forzar a LLVM a usar un GPR,
    /// evitando un problema de codegen donde `bitcast double → i64` + `inttoptr` puede
    /// dejar el valor atrapado en un registro XMM.
    /// Retorna el nombre del valor SSA puntero del `target_ty` dado (ej. "i8*", "double*", "i64*").
    pub fn decode_ptr(&mut self, double_val: &str, target_ty: &str) -> String {
        let i = self.tmp(); self.emit(&format!("{} = bitcast double {} to i64", i, double_val));
        let a = self.tmp(); self.emit(&format!("{} = alloca i64", a));
        self.emit(&format!("store i64 {}, i64* {}", i, a));
        let i2 = self.tmp(); self.emit(&format!("{} = load i64, i64* {}", i2, a));
        let p = self.tmp(); self.emit(&format!("{} = inttoptr i64 {} to {}", p, i2, target_ty));
        p
    }

    /// Asignar un type-id para una clase.
    pub fn alloc_type_id(&mut self) -> u32 {
        let id = self.next_type_id;
        self.next_type_id += 1;
        id
    }
}
