; HULK -> LLVM IR  (generated by Albert XD )
declare i32 @printf(i8*, ...)
declare i32 @puts(i8*)
declare i8* @malloc(i64)
declare i8* @realloc(i8*, i64)
declare void @free(i8*)
declare i64 @strlen(i8*)
declare i8* @strcpy(i8*, i8*)
declare i8* @strcat(i8*, i8*)
declare i32 @snprintf(i8*, i64, i8*, ...)
declare i32 @rand()
declare void @srand(i32)
declare i64 @time(i64*)
declare void @abort()
declare double @llvm.pow.f64(double, double)
declare double @llvm.sin.f64(double)
declare double @llvm.cos.f64(double)
declare double @llvm.exp.f64(double)
declare double @llvm.log.f64(double)
declare double @llvm.sqrt.f64(double)
declare double @llvm.fabs.f64(double)
declare double @llvm.floor.f64(double)

@.fmt_int  = private unnamed_addr constant [5 x i8] c"%.0f\00"
@.fmt_num  = private unnamed_addr constant [5 x i8] c"%.6g\00"
@.fmt_str  = private unnamed_addr constant [3 x i8] c"%s\00"
@.fmt_nl   = private unnamed_addr constant [2 x i8] c"\0A\00"
@.true_s   = private unnamed_addr constant [5 x i8] c"true\00"
@.false_s  = private unnamed_addr constant [6 x i8] c"false\00"
@.space_s  = private unnamed_addr constant [2 x i8] c" \00"
@.empty_s  = private unnamed_addr constant [1 x i8] c"\00"
@.vec_open = private unnamed_addr constant [2 x i8] c"[\00"
@.vec_close = private unnamed_addr constant [2 x i8] c"]\00"
@.vec_sep  = private unnamed_addr constant [3 x i8] c", \00"
@.oob_msg  = private unnamed_addr constant [36 x i8] c"Runtime error: index out of bounds\0A\00"
@.rand_seeded = global i1 false
%__Vector = type { i64, double*, double, double }

@.slit_11 = private unnamed_addr constant [20 x i8] c"Vector de números:\00"
@.slit_19 = private unnamed_addr constant [17 x i8] c"Primer elemento:\00"
@.slit_45 = private unnamed_addr constant [18 x i8] c"Último elemento:\00"
@.slit_126 = private unnamed_addr constant [11 x i8] c"Cuadrados:\00"
@.slit_134 = private unnamed_addr constant [15 x i8] c"Cuadrado de 3:\00"
@.slit_166 = private unnamed_addr constant [15 x i8] c"Vector vacío:\00"
@.slit_175 = private unnamed_addr constant [6 x i8] c"hello\00"
@.slit_180 = private unnamed_addr constant [20 x i8] c"Number como Object:\00"
@.slit_187 = private unnamed_addr constant [20 x i8] c"String como Object:\00"
@.slit_194 = private unnamed_addr constant [6 x i8] c"hello\00"
@.slit_201 = private unnamed_addr constant [21 x i8] c"Boolean como Object:\00"
@.slit_305 = private unnamed_addr constant [24 x i8] c"Triple transformación:\00"
@.slit_312 = private unnamed_addr constant [10 x i8] c"Original:\00"
@.slit_320 = private unnamed_addr constant [11 x i8] c"Duplicado:\00"
@.slit_328 = private unnamed_addr constant [14 x i8] c"Incrementado:\00"
@.slit_337 = private unnamed_addr constant [4 x i8] c"---\00"
@.slit_345 = private unnamed_addr constant [4 x i8] c"---\00"
@.slit_353 = private unnamed_addr constant [4 x i8] c"---\00"
@.slit_361 = private unnamed_addr constant [4 x i8] c"---\00"
@.slit_369 = private unnamed_addr constant [39 x i8] c"Todos los tests pasaron correctamente!\00"

define i8* @__Vector_new(double* %data, double %length) {
entry:
  %obj = call i8* @malloc(i64 32)
  %ptr = bitcast i8* %obj to %__Vector*
  
  ; Almacenar type_id
  %tid_ptr = getelementptr inbounds %__Vector, %__Vector* %ptr, i32 0, i32 0
  store i64 1, i64* %tid_ptr
  
  ; Almacenar data pointer
  %data_ptr = getelementptr inbounds %__Vector, %__Vector* %ptr, i32 0, i32 1
  store double* %data, double** %data_ptr
  
  ; Almacenar length
  %len_ptr = getelementptr inbounds %__Vector, %__Vector* %ptr, i32 0, i32 2
  store double %length, double* %len_ptr
  
  ; Inicializar index en -1
  %idx_ptr = getelementptr inbounds %__Vector, %__Vector* %ptr, i32 0, i32 3
  store double -1.0, double* %idx_ptr
  
  ret i8* %obj
}

define double @__Vector_size(i8* %self) {
entry:
  %ptr = bitcast i8* %self to %__Vector*
  %len_ptr = getelementptr inbounds %__Vector, %__Vector* %ptr, i32 0, i32 2
  %len = load double, double* %len_ptr
  ret double %len
}

define double @__Vector_next(i8* %self) {
entry:
  %ptr = bitcast i8* %self to %__Vector*
  
  ; Cargar índice actual
  %idx_ptr = getelementptr inbounds %__Vector, %__Vector* %ptr, i32 0, i32 3
  %idx = load double, double* %idx_ptr
  
  ; Incrementar índice
  %next_idx = fadd double %idx, 1.0
  store double %next_idx, double* %idx_ptr
  
  ; Cargar length
  %len_ptr = getelementptr inbounds %__Vector, %__Vector* %ptr, i32 0, i32 2
  %len = load double, double* %len_ptr
  
  ; Comparar: next_idx < len
  %cond = fcmp olt double %next_idx, %len
  %result = select i1 %cond, double 1.0, double 0.0
  ret double %result
}

define double @__Vector_get_current(i8* %self) {
entry:
  %ptr = bitcast i8* %self to %__Vector*
  
  ; Cargar índice actual
  %idx_ptr = getelementptr inbounds %__Vector, %__Vector* %ptr, i32 0, i32 3
  %idx_d = load double, double* %idx_ptr
  %idx = fptosi double %idx_d to i64
  
  ; Cargar data pointer
  %data_ptr = getelementptr inbounds %__Vector, %__Vector* %ptr, i32 0, i32 1
  %data = load double*, double** %data_ptr
  
  ; Acceder al elemento en data[idx]
  %elem_ptr = getelementptr double, double* %data, i64 %idx
  %value = load double, double* %elem_ptr
  ret double %value
}

define double @test_number_vector() {
entry:
  %t0 = call i8* @malloc(i64 40)
  %t1 = bitcast i8* %t0 to double*
  %t2 = getelementptr double, double* %t1, i64 0
  store double 1.0e0, double* %t2
  %t3 = getelementptr double, double* %t1, i64 1
  store double 2.0e0, double* %t3
  %t4 = getelementptr double, double* %t1, i64 2
  store double 3.0e0, double* %t4
  %t5 = getelementptr double, double* %t1, i64 3
  store double 4.0e0, double* %t5
  %t6 = getelementptr double, double* %t1, i64 4
  store double 5.0e0, double* %t6
  %t7 = call i8* @__Vector_new(double* %t1, double 5.0e0)
  %t8 = ptrtoint i8* %t7 to i64
  %t9 = bitcast i64 %t8 to double
  %t10 = alloca double
  store double %t9, double* %t10
  %t12 = ptrtoint i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.slit_11, i64 0, i64 0) to i64
  %t13 = bitcast i64 %t12 to double
  %t14 = bitcast double %t13 to i64
  %t15 = alloca i64
  store i64 %t14, i64* %t15
  %t16 = load i64, i64* %t15
  %t17 = inttoptr i64 %t16 to i8*
  call i32 @puts(i8* %t17)
  %t18 = load double, double* %t10
  call void @__hulk_print_vector(double %t18)
  %t20 = ptrtoint i8* getelementptr inbounds ([17 x i8], [17 x i8]* @.slit_19, i64 0, i64 0) to i64
  %t21 = bitcast i64 %t20 to double
  %t22 = bitcast double %t21 to i64
  %t23 = alloca i64
  store i64 %t22, i64* %t23
  %t24 = load i64, i64* %t23
  %t25 = inttoptr i64 %t24 to i8*
  call i32 @puts(i8* %t25)
  %t26 = load double, double* %t10
  %t27 = bitcast double %t26 to i64
  %t28 = alloca i64
  store i64 %t27, i64* %t28
  %t29 = load i64, i64* %t28
  %t30 = inttoptr i64 %t29 to i8*
  %t31 = bitcast i8* %t30 to %__Vector*
  %t32 = getelementptr inbounds %__Vector, %__Vector* %t31, i32 0, i32 2
  %t33 = load double, double* %t32
  %t34 = fptosi double %t33 to i64
  %t35 = fptosi double 0.0e0 to i64
  %t36 = icmp slt i64 %t35, 0
  %t37 = icmp sge i64 %t35, %t34
  %t38 = or i1 %t36, %t37
  br i1 %t38, label %idx_oob_40, label %idx_ok_39
idx_oob_40:
  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.oob_msg, i64 0, i64 0))
  call void @abort()
  unreachable
idx_ok_39:
  %t41 = getelementptr inbounds %__Vector, %__Vector* %t31, i32 0, i32 1
  %t42 = load double*, double** %t41
  %t43 = getelementptr double, double* %t42, i64 %t35
  %t44 = load double, double* %t43
  call void @__hulk_print_val(double %t44)
  %t46 = ptrtoint i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.slit_45, i64 0, i64 0) to i64
  %t47 = bitcast i64 %t46 to double
  %t48 = bitcast double %t47 to i64
  %t49 = alloca i64
  store i64 %t48, i64* %t49
  %t50 = load i64, i64* %t49
  %t51 = inttoptr i64 %t50 to i8*
  call i32 @puts(i8* %t51)
  %t52 = load double, double* %t10
  %t53 = bitcast double %t52 to i64
  %t54 = alloca i64
  store i64 %t53, i64* %t54
  %t55 = load i64, i64* %t54
  %t56 = inttoptr i64 %t55 to i8*
  %t57 = bitcast i8* %t56 to %__Vector*
  %t58 = getelementptr inbounds %__Vector, %__Vector* %t57, i32 0, i32 2
  %t59 = load double, double* %t58
  %t60 = fptosi double %t59 to i64
  %t61 = fptosi double 4.0e0 to i64
  %t62 = icmp slt i64 %t61, 0
  %t63 = icmp sge i64 %t61, %t60
  %t64 = or i1 %t62, %t63
  br i1 %t64, label %idx_oob_66, label %idx_ok_65
idx_oob_66:
  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.oob_msg, i64 0, i64 0))
  call void @abort()
  unreachable
idx_ok_65:
  %t67 = getelementptr inbounds %__Vector, %__Vector* %t57, i32 0, i32 1
  %t68 = load double*, double** %t67
  %t69 = getelementptr double, double* %t68, i64 %t61
  %t70 = load double, double* %t69
  call void @__hulk_print_val(double %t70)
  ret double 0.0e0
}

define double @test_comprehension() {
entry:
  %t71 = call i8* @malloc(i64 40)
  %t72 = bitcast i8* %t71 to double*
  %t73 = getelementptr double, double* %t72, i64 0
  store double 1.0e0, double* %t73
  %t74 = getelementptr double, double* %t72, i64 1
  store double 2.0e0, double* %t74
  %t75 = getelementptr double, double* %t72, i64 2
  store double 3.0e0, double* %t75
  %t76 = getelementptr double, double* %t72, i64 3
  store double 4.0e0, double* %t76
  %t77 = getelementptr double, double* %t72, i64 4
  store double 5.0e0, double* %t77
  %t78 = call i8* @__Vector_new(double* %t72, double 5.0e0)
  %t79 = ptrtoint i8* %t78 to i64
  %t80 = bitcast i64 %t79 to double
  %t81 = alloca double
  store double %t80, double* %t81
  %t82 = load double, double* %t81
  %t83 = bitcast double %t82 to i64
  %t84 = alloca i64
  store i64 %t83, i64* %t84
  %t85 = load i64, i64* %t84
  %t86 = inttoptr i64 %t85 to i8*
  %t87 = mul i64 101, 8
  %t88 = call i8* @malloc(i64 %t87)
  %t89 = bitcast i8* %t88 to double*
  %t90 = alloca i64
  store i64 0, i64* %t90
  %t91 = alloca i64
  store i64 100, i64* %t91
  %t92 = alloca double*
  store double* %t89, double** %t92
  br label %vgc_93
vgc_93:
  %t96 = call double @__Vector_next(i8* %t86)
  %t97 = fcmp one double %t96, 0.0
  br i1 %t97, label %vgb_94, label %vge_95
vgb_94:
  %t98 = call double @__Vector_get_current(i8* %t86)
  %t99 = alloca double
  store double %t98, double* %t99
  %t100 = load double, double* %t99
  %t101 = load double, double* %t99
  %t102 = fmul double %t100, %t101
  %t103 = load i64, i64* %t90
  %t104 = load i64, i64* %t91
  %t105 = icmp sge i64 %t103, %t104
  br i1 %t105, label %vg_grow_106, label %vg_store_107
vg_grow_106:
  %t108 = mul i64 %t104, 2
  %t109 = add i64 %t108, 1
  %t110 = mul i64 %t109, 8
  %t111 = load double*, double** %t92
  %t112 = bitcast double* %t111 to i8*
  %t113 = call i8* @realloc(i8* %t112, i64 %t110)
  %t114 = bitcast i8* %t113 to double*
  store double* %t114, double** %t92
  store i64 %t108, i64* %t91
  br label %vg_store_107
vg_store_107:
  %t115 = load double*, double** %t92
  %t116 = add i64 %t103, 1
  %t117 = getelementptr double, double* %t115, i64 %t116
  store double %t102, double* %t117
  %t118 = add i64 %t103, 1
  store i64 %t118, i64* %t90
  br label %vgc_93
vge_95:
  %t119 = load i64, i64* %t90
  %t120 = sitofp i64 %t119 to double
  %t121 = load double*, double** %t92
  %t122 = call i8* @__Vector_new(double* %t121, double %t120)
  %t123 = ptrtoint i8* %t122 to i64
  %t124 = bitcast i64 %t123 to double
  %t125 = alloca double
  store double %t124, double* %t125
  %t127 = ptrtoint i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.slit_126, i64 0, i64 0) to i64
  %t128 = bitcast i64 %t127 to double
  %t129 = bitcast double %t128 to i64
  %t130 = alloca i64
  store i64 %t129, i64* %t130
  %t131 = load i64, i64* %t130
  %t132 = inttoptr i64 %t131 to i8*
  call i32 @puts(i8* %t132)
  %t133 = load double, double* %t125
  call void @__hulk_print_vector(double %t133)
  %t135 = ptrtoint i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.slit_134, i64 0, i64 0) to i64
  %t136 = bitcast i64 %t135 to double
  %t137 = bitcast double %t136 to i64
  %t138 = alloca i64
  store i64 %t137, i64* %t138
  %t139 = load i64, i64* %t138
  %t140 = inttoptr i64 %t139 to i8*
  call i32 @puts(i8* %t140)
  %t141 = load double, double* %t125
  %t142 = bitcast double %t141 to i64
  %t143 = alloca i64
  store i64 %t142, i64* %t143
  %t144 = load i64, i64* %t143
  %t145 = inttoptr i64 %t144 to i8*
  %t146 = bitcast i8* %t145 to %__Vector*
  %t147 = getelementptr inbounds %__Vector, %__Vector* %t146, i32 0, i32 2
  %t148 = load double, double* %t147
  %t149 = fptosi double %t148 to i64
  %t150 = fptosi double 2.0e0 to i64
  %t151 = icmp slt i64 %t150, 0
  %t152 = icmp sge i64 %t150, %t149
  %t153 = or i1 %t151, %t152
  br i1 %t153, label %idx_oob_155, label %idx_ok_154
idx_oob_155:
  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.oob_msg, i64 0, i64 0))
  call void @abort()
  unreachable
idx_ok_154:
  %t156 = getelementptr inbounds %__Vector, %__Vector* %t146, i32 0, i32 1
  %t157 = load double*, double** %t156
  %t158 = getelementptr double, double* %t157, i64 %t150
  %t159 = load double, double* %t158
  call void @__hulk_print_val(double %t159)
  ret double 0.0e0
}

define double @test_empty_vector() {
entry:
  %t160 = call i8* @malloc(i64 0)
  %t161 = bitcast i8* %t160 to double*
  %t162 = call i8* @__Vector_new(double* %t161, double 0.0e0)
  %t163 = ptrtoint i8* %t162 to i64
  %t164 = bitcast i64 %t163 to double
  %t165 = alloca double
  store double %t164, double* %t165
  %t167 = ptrtoint i8* getelementptr inbounds ([15 x i8], [15 x i8]* @.slit_166, i64 0, i64 0) to i64
  %t168 = bitcast i64 %t167 to double
  %t169 = bitcast double %t168 to i64
  %t170 = alloca i64
  store i64 %t169, i64* %t170
  %t171 = load i64, i64* %t170
  %t172 = inttoptr i64 %t171 to i8*
  call i32 @puts(i8* %t172)
  %t173 = load double, double* %t165
  call void @__hulk_print_vector(double %t173)
  ret double 0.0e0
}

define double @test_conforming() {
entry:
  %t174 = alloca double
  store double 4.2e1, double* %t174
  %t176 = ptrtoint i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.slit_175, i64 0, i64 0) to i64
  %t177 = bitcast i64 %t176 to double
  %t178 = alloca double
  store double %t177, double* %t178
  %t179 = alloca double
  store double 1.0, double* %t179
  %t181 = ptrtoint i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.slit_180, i64 0, i64 0) to i64
  %t182 = bitcast i64 %t181 to double
  %t183 = bitcast double %t182 to i64
  %t184 = alloca i64
  store i64 %t183, i64* %t184
  %t185 = load i64, i64* %t184
  %t186 = inttoptr i64 %t185 to i8*
  call i32 @puts(i8* %t186)
  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.fmt_num, i64 0, i64 0), double 4.2e1)
  call i32 @puts(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.empty_s, i64 0, i64 0))
  %t188 = ptrtoint i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.slit_187, i64 0, i64 0) to i64
  %t189 = bitcast i64 %t188 to double
  %t190 = bitcast double %t189 to i64
  %t191 = alloca i64
  store i64 %t190, i64* %t191
  %t192 = load i64, i64* %t191
  %t193 = inttoptr i64 %t192 to i8*
  call i32 @puts(i8* %t193)
  %t195 = ptrtoint i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.slit_194, i64 0, i64 0) to i64
  %t196 = bitcast i64 %t195 to double
  %t197 = bitcast double %t196 to i64
  %t198 = alloca i64
  store i64 %t197, i64* %t198
  %t199 = load i64, i64* %t198
  %t200 = inttoptr i64 %t199 to i8*
  call i32 @puts(i8* %t200)
  %t202 = ptrtoint i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.slit_201, i64 0, i64 0) to i64
  %t203 = bitcast i64 %t202 to double
  %t204 = bitcast double %t203 to i64
  %t205 = alloca i64
  store i64 %t204, i64* %t205
  %t206 = load i64, i64* %t205
  %t207 = inttoptr i64 %t206 to i8*
  call i32 @puts(i8* %t207)
  %t208 = fcmp one double 1.0, 0.0
  %t209 = select i1 %t208, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.true_s, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.false_s, i64 0, i64 0)
  call i32 @puts(i8* %t209)
  ret double 0.0e0
}

define double @test_nested_comprehension() {
entry:
  %t210 = call i8* @malloc(i64 24)
  %t211 = bitcast i8* %t210 to double*
  %t212 = getelementptr double, double* %t211, i64 0
  store double 1.0e0, double* %t212
  %t213 = getelementptr double, double* %t211, i64 1
  store double 2.0e0, double* %t213
  %t214 = getelementptr double, double* %t211, i64 2
  store double 3.0e0, double* %t214
  %t215 = call i8* @__Vector_new(double* %t211, double 3.0e0)
  %t216 = ptrtoint i8* %t215 to i64
  %t217 = bitcast i64 %t216 to double
  %t218 = alloca double
  store double %t217, double* %t218
  %t219 = load double, double* %t218
  %t220 = bitcast double %t219 to i64
  %t221 = alloca i64
  store i64 %t220, i64* %t221
  %t222 = load i64, i64* %t221
  %t223 = inttoptr i64 %t222 to i8*
  %t224 = mul i64 101, 8
  %t225 = call i8* @malloc(i64 %t224)
  %t226 = bitcast i8* %t225 to double*
  %t227 = alloca i64
  store i64 0, i64* %t227
  %t228 = alloca i64
  store i64 100, i64* %t228
  %t229 = alloca double*
  store double* %t226, double** %t229
  br label %vgc_230
vgc_230:
  %t233 = call double @__Vector_next(i8* %t223)
  %t234 = fcmp one double %t233, 0.0
  br i1 %t234, label %vgb_231, label %vge_232
vgb_231:
  %t235 = call double @__Vector_get_current(i8* %t223)
  %t236 = alloca double
  store double %t235, double* %t236
  %t237 = load double, double* %t236
  %t238 = fmul double %t237, 2.0e0
  %t239 = load i64, i64* %t227
  %t240 = load i64, i64* %t228
  %t241 = icmp sge i64 %t239, %t240
  br i1 %t241, label %vg_grow_242, label %vg_store_243
vg_grow_242:
  %t244 = mul i64 %t240, 2
  %t245 = add i64 %t244, 1
  %t246 = mul i64 %t245, 8
  %t247 = load double*, double** %t229
  %t248 = bitcast double* %t247 to i8*
  %t249 = call i8* @realloc(i8* %t248, i64 %t246)
  %t250 = bitcast i8* %t249 to double*
  store double* %t250, double** %t229
  store i64 %t244, i64* %t228
  br label %vg_store_243
vg_store_243:
  %t251 = load double*, double** %t229
  %t252 = add i64 %t239, 1
  %t253 = getelementptr double, double* %t251, i64 %t252
  store double %t238, double* %t253
  %t254 = add i64 %t239, 1
  store i64 %t254, i64* %t227
  br label %vgc_230
vge_232:
  %t255 = load i64, i64* %t227
  %t256 = sitofp i64 %t255 to double
  %t257 = load double*, double** %t229
  %t258 = call i8* @__Vector_new(double* %t257, double %t256)
  %t259 = ptrtoint i8* %t258 to i64
  %t260 = bitcast i64 %t259 to double
  %t261 = alloca double
  store double %t260, double* %t261
  %t262 = load double, double* %t261
  %t263 = bitcast double %t262 to i64
  %t264 = alloca i64
  store i64 %t263, i64* %t264
  %t265 = load i64, i64* %t264
  %t266 = inttoptr i64 %t265 to i8*
  %t267 = mul i64 101, 8
  %t268 = call i8* @malloc(i64 %t267)
  %t269 = bitcast i8* %t268 to double*
  %t270 = alloca i64
  store i64 0, i64* %t270
  %t271 = alloca i64
  store i64 100, i64* %t271
  %t272 = alloca double*
  store double* %t269, double** %t272
  br label %vgc_273
vgc_273:
  %t276 = call double @__Vector_next(i8* %t266)
  %t277 = fcmp one double %t276, 0.0
  br i1 %t277, label %vgb_274, label %vge_275
vgb_274:
  %t278 = call double @__Vector_get_current(i8* %t266)
  %t279 = alloca double
  store double %t278, double* %t279
  %t280 = load double, double* %t279
  %t281 = fadd double %t280, 1.0e0
  %t282 = load i64, i64* %t270
  %t283 = load i64, i64* %t271
  %t284 = icmp sge i64 %t282, %t283
  br i1 %t284, label %vg_grow_285, label %vg_store_286
vg_grow_285:
  %t287 = mul i64 %t283, 2
  %t288 = add i64 %t287, 1
  %t289 = mul i64 %t288, 8
  %t290 = load double*, double** %t272
  %t291 = bitcast double* %t290 to i8*
  %t292 = call i8* @realloc(i8* %t291, i64 %t289)
  %t293 = bitcast i8* %t292 to double*
  store double* %t293, double** %t272
  store i64 %t287, i64* %t271
  br label %vg_store_286
vg_store_286:
  %t294 = load double*, double** %t272
  %t295 = add i64 %t282, 1
  %t296 = getelementptr double, double* %t294, i64 %t295
  store double %t281, double* %t296
  %t297 = add i64 %t282, 1
  store i64 %t297, i64* %t270
  br label %vgc_273
vge_275:
  %t298 = load i64, i64* %t270
  %t299 = sitofp i64 %t298 to double
  %t300 = load double*, double** %t272
  %t301 = call i8* @__Vector_new(double* %t300, double %t299)
  %t302 = ptrtoint i8* %t301 to i64
  %t303 = bitcast i64 %t302 to double
  %t304 = alloca double
  store double %t303, double* %t304
  %t306 = ptrtoint i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.slit_305, i64 0, i64 0) to i64
  %t307 = bitcast i64 %t306 to double
  %t308 = bitcast double %t307 to i64
  %t309 = alloca i64
  store i64 %t308, i64* %t309
  %t310 = load i64, i64* %t309
  %t311 = inttoptr i64 %t310 to i8*
  call i32 @puts(i8* %t311)
  %t313 = ptrtoint i8* getelementptr inbounds ([10 x i8], [10 x i8]* @.slit_312, i64 0, i64 0) to i64
  %t314 = bitcast i64 %t313 to double
  %t315 = bitcast double %t314 to i64
  %t316 = alloca i64
  store i64 %t315, i64* %t316
  %t317 = load i64, i64* %t316
  %t318 = inttoptr i64 %t317 to i8*
  call i32 @puts(i8* %t318)
  %t319 = load double, double* %t218
  call void @__hulk_print_vector(double %t319)
  %t321 = ptrtoint i8* getelementptr inbounds ([11 x i8], [11 x i8]* @.slit_320, i64 0, i64 0) to i64
  %t322 = bitcast i64 %t321 to double
  %t323 = bitcast double %t322 to i64
  %t324 = alloca i64
  store i64 %t323, i64* %t324
  %t325 = load i64, i64* %t324
  %t326 = inttoptr i64 %t325 to i8*
  call i32 @puts(i8* %t326)
  %t327 = load double, double* %t261
  call void @__hulk_print_vector(double %t327)
  %t329 = ptrtoint i8* getelementptr inbounds ([14 x i8], [14 x i8]* @.slit_328, i64 0, i64 0) to i64
  %t330 = bitcast i64 %t329 to double
  %t331 = bitcast double %t330 to i64
  %t332 = alloca i64
  store i64 %t331, i64* %t332
  %t333 = load i64, i64* %t332
  %t334 = inttoptr i64 %t333 to i8*
  call i32 @puts(i8* %t334)
  %t335 = load double, double* %t304
  call void @__hulk_print_vector(double %t335)
  ret double 0.0e0
}

define double @__hulk_main() {
entry:
  %t336 = call double @test_number_vector()
  %t338 = ptrtoint i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.slit_337, i64 0, i64 0) to i64
  %t339 = bitcast i64 %t338 to double
  %t340 = bitcast double %t339 to i64
  %t341 = alloca i64
  store i64 %t340, i64* %t341
  %t342 = load i64, i64* %t341
  %t343 = inttoptr i64 %t342 to i8*
  call i32 @puts(i8* %t343)
  %t344 = call double @test_comprehension()
  %t346 = ptrtoint i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.slit_345, i64 0, i64 0) to i64
  %t347 = bitcast i64 %t346 to double
  %t348 = bitcast double %t347 to i64
  %t349 = alloca i64
  store i64 %t348, i64* %t349
  %t350 = load i64, i64* %t349
  %t351 = inttoptr i64 %t350 to i8*
  call i32 @puts(i8* %t351)
  %t352 = call double @test_empty_vector()
  %t354 = ptrtoint i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.slit_353, i64 0, i64 0) to i64
  %t355 = bitcast i64 %t354 to double
  %t356 = bitcast double %t355 to i64
  %t357 = alloca i64
  store i64 %t356, i64* %t357
  %t358 = load i64, i64* %t357
  %t359 = inttoptr i64 %t358 to i8*
  call i32 @puts(i8* %t359)
  %t360 = call double @test_conforming()
  %t362 = ptrtoint i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.slit_361, i64 0, i64 0) to i64
  %t363 = bitcast i64 %t362 to double
  %t364 = bitcast double %t363 to i64
  %t365 = alloca i64
  store i64 %t364, i64* %t365
  %t366 = load i64, i64* %t365
  %t367 = inttoptr i64 %t366 to i8*
  call i32 @puts(i8* %t367)
  %t368 = call double @test_nested_comprehension()
  %t370 = ptrtoint i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.slit_369, i64 0, i64 0) to i64
  %t371 = bitcast i64 %t370 to double
  %t372 = bitcast double %t371 to i64
  %t373 = alloca i64
  store i64 %t372, i64* %t373
  %t374 = load i64, i64* %t373
  %t375 = inttoptr i64 %t374 to i8*
  call i32 @puts(i8* %t375)
  ret double 0.0e0
}

define i8* @__hulk_num_to_str(double %val) {
entry:
  %fl = call double @llvm.floor.f64(double %val)
  %diff = fsub double %val, %fl
  %is_int = fcmp oeq double %diff, 0.0
  %abs_val = call double @llvm.fabs.f64(double %val)
  %small_enough = fcmp olt double %abs_val, 1.0e15
  %use_int = and i1 %is_int, %small_enough
  br i1 %use_int, label %fmt_as_int, label %fmt_as_dbl
fmt_as_int:
  %ilen = call i32 (i8*, i64, i8*, ...) @snprintf(i8* null, i64 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.fmt_int, i64 0, i64 0), double %val)
  %ilen64 = sext i32 %ilen to i64
  %ibufsz = add i64 %ilen64, 1
  %ibuf = call i8* @malloc(i64 %ibufsz)
  call i32 (i8*, i64, i8*, ...) @snprintf(i8* %ibuf, i64 %ibufsz, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.fmt_int, i64 0, i64 0), double %val)
  ret i8* %ibuf
fmt_as_dbl:
  %dlen = call i32 (i8*, i64, i8*, ...) @snprintf(i8* null, i64 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.fmt_num, i64 0, i64 0), double %val)
  %dlen64 = sext i32 %dlen to i64
  %dbufsz = add i64 %dlen64, 1
  %dbuf = call i8* @malloc(i64 %dbufsz)
  call i32 (i8*, i64, i8*, ...) @snprintf(i8* %dbuf, i64 %dbufsz, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.fmt_num, i64 0, i64 0), double %val)
  ret i8* %dbuf
}

define i8* @__hulk_bool_to_str(double %val) {
entry:
  %cond = fcmp one double %val, 0.0
  %res = select i1 %cond, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.true_s, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.false_s, i64 0, i64 0)
  ret i8* %res
}

define void @__hulk_print_val(double %val) {
entry:
  ; Respaldo: imprimir como número (por defecto seguro para tipo Unknown)
  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.fmt_num, i64 0, i64 0), double %val)
  call i32 @puts(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.empty_s, i64 0, i64 0))
  ret void
}

define i8* @__hulk_to_str(double %val) {
entry:
  %numstr = call i8* @__hulk_num_to_str(double %val)
  ret i8* %numstr
}

define void @__hulk_print_vector(double %val) {
entry:
  ; Decodificar objeto Vector
  %pi = bitcast double %val to i64
  %obj_ptr = inttoptr i64 %pi to i8*
  %ptr = bitcast i8* %obj_ptr to %__Vector*
  
  ; Leer longitud del vector
  %len_ptr = getelementptr inbounds %__Vector, %__Vector* %ptr, i32 0, i32 2
  %len_d = load double, double* %len_ptr
  %len_i = fptosi double %len_d to i64
  
  ; Leer data pointer
  %data_ptr_loc = getelementptr inbounds %__Vector, %__Vector* %ptr, i32 0, i32 1
  %data_ptr = load double*, double** %data_ptr_loc
  
  ; Imprimir apertura
  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.vec_open, i64 0, i64 0))
  
  ; Inicializar índice
  %idx_ptr = alloca i64
  store i64 0, i64* %idx_ptr
  br label %loop_cond
  
loop_cond:
  %i = load i64, i64* %idx_ptr
  %cond = icmp slt i64 %i, %len_i
  br i1 %cond, label %loop_body, label %loop_end
  
loop_body:
  ; Leer elemento en posición i
  %elem_ptr = getelementptr double, double* %data_ptr, i64 %i
  %elem = load double, double* %elem_ptr
  
  ; Imprimir separador si no es el primero
  %is_first = icmp eq i64 %i, 0
  br i1 %is_first, label %print_elem, label %print_sep
  
print_sep:
  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.vec_sep, i64 0, i64 0))
  br label %print_elem
  
print_elem:
  ; Imprimir el elemento
  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.fmt_num, i64 0, i64 0), double %elem)
  
  ; Incrementar índice
  %next_i = add i64 %i, 1
  store i64 %next_i, i64* %idx_ptr
  br label %loop_cond
  
loop_end:
  ; Imprimir cierre
  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.vec_close, i64 0, i64 0))
  call i32 @puts(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.empty_s, i64 0, i64 0))
  ret void
}

define i8* @__hulk_vector_to_str(double %val) {
entry:
  ; Decodificar objeto Vector
  %pi = bitcast double %val to i64
  %obj_ptr = inttoptr i64 %pi to i8*
  %ptr = bitcast i8* %obj_ptr to %__Vector*
  
  ; Leer longitud
  %len_ptr = getelementptr inbounds %__Vector, %__Vector* %ptr, i32 0, i32 2
  %len_d = load double, double* %len_ptr
  %len_i = fptosi double %len_d to i64
  
  ; Leer data pointer
  %data_ptr_loc = getelementptr inbounds %__Vector, %__Vector* %ptr, i32 0, i32 1
  %data_ptr = load double*, double** %data_ptr_loc
  
  ; Calcular tamaño aproximado del buffer (20 chars por número + separadores)
  %est_size = mul i64 %len_i, 20
  %buf_size = add i64 %est_size, 100
  %buf_raw = call i8* @malloc(i64 %buf_size)
  
  ; Copiar '['
  %pos_ptr = alloca i64
  store i64 0, i64* %pos_ptr
  %open_ptr = getelementptr i8, i8* %buf_raw, i64 0
  store i8 91, i8* %open_ptr  ; '[' = 91
  store i64 1, i64* %pos_ptr
  
  ; Loop sobre elementos
  %idx_ptr = alloca i64
  store i64 0, i64* %idx_ptr
  br label %loop_cond
  
loop_cond:
  %i = load i64, i64* %idx_ptr
  %cond = icmp slt i64 %i, %len_i
  br i1 %cond, label %loop_body, label %loop_end
  
loop_body:
  ; Agregar separador si no es el primero
  %is_first = icmp eq i64 %i, 0
  br i1 %is_first, label %get_elem, label %add_sep
  
add_sep:
  %pos1 = load i64, i64* %pos_ptr
  %sep1_ptr = getelementptr i8, i8* %buf_raw, i64 %pos1
  store i8 44, i8* %sep1_ptr  ; ',' = 44
  %pos2 = add i64 %pos1, 1
  %sep2_ptr = getelementptr i8, i8* %buf_raw, i64 %pos2
  store i8 32, i8* %sep2_ptr  ; ' ' = 32
  %pos3 = add i64 %pos2, 1
  store i64 %pos3, i64* %pos_ptr
  br label %get_elem
  
get_elem:
  ; Leer elemento y convertir a string
  %elem_ptr = getelementptr double, double* %data_ptr, i64 %i
  %elem = load double, double* %elem_ptr
  %elem_str = call i8* @__hulk_num_to_str(double %elem)
  
  ; Concatenar al buffer
  %pos4 = load i64, i64* %pos_ptr
  %dest_ptr = getelementptr i8, i8* %buf_raw, i64 %pos4
  call i8* @strcpy(i8* %dest_ptr, i8* %elem_str)
  %elem_len = call i64 @strlen(i8* %elem_str)
  %pos5 = add i64 %pos4, %elem_len
  store i64 %pos5, i64* %pos_ptr
  call void @free(i8* %elem_str)
  
  ; Siguiente
  %next_i = add i64 %i, 1
  store i64 %next_i, i64* %idx_ptr
  br label %loop_cond
  
loop_end:
  ; Agregar ']'
  %pos6 = load i64, i64* %pos_ptr
  %close_ptr = getelementptr i8, i8* %buf_raw, i64 %pos6
  store i8 93, i8* %close_ptr  ; ']' = 93
  %pos7 = add i64 %pos6, 1
  %null_ptr = getelementptr i8, i8* %buf_raw, i64 %pos7
  store i8 0, i8* %null_ptr    ; null terminator
  
  ret i8* %buf_raw
}

define i32 @main() {
entry:
  call double @__hulk_main()
  ret i32 0
}

