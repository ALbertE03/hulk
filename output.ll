; HULK -> LLVM IR  (generated by Albert XD )
declare i32 @printf(i8*, ...)
declare i32 @puts(i8*)
declare i8* @malloc(i64)
declare i8* @realloc(i8*, i64)
declare void @free(i8*)
declare i64 @strlen(i8*)
declare i8* @strcpy(i8*, i8*)
declare i8* @strcat(i8*, i8*)
declare i32 @snprintf(i8*, i64, i8*, ...)
declare i32 @rand()
declare void @srand(i32)
declare i64 @time(i64*)
declare void @abort()
declare double @llvm.pow.f64(double, double)
declare double @llvm.sin.f64(double)
declare double @llvm.cos.f64(double)
declare double @llvm.exp.f64(double)
declare double @llvm.log.f64(double)
declare double @llvm.sqrt.f64(double)
declare double @llvm.fabs.f64(double)
declare double @llvm.floor.f64(double)

@.fmt_int  = private unnamed_addr constant [5 x i8] c"%.0f\00"
@.fmt_num  = private unnamed_addr constant [5 x i8] c"%.6g\00"
@.fmt_str  = private unnamed_addr constant [3 x i8] c"%s\00"
@.fmt_nl   = private unnamed_addr constant [2 x i8] c"\0A\00"
@.true_s   = private unnamed_addr constant [5 x i8] c"true\00"
@.false_s  = private unnamed_addr constant [6 x i8] c"false\00"
@.space_s  = private unnamed_addr constant [2 x i8] c" \00"
@.empty_s  = private unnamed_addr constant [1 x i8] c"\00"
@.oob_msg  = private unnamed_addr constant [36 x i8] c"Runtime error: index out of bounds\0A\00"
@.rand_seeded = global i1 false

%T.Range = type { i64, double, double, double }
%T.IsOddWrapper = type { i64 }

define i8* @Range_new(double %min, double %max) {
entry:
  %t0 = call i8* @malloc(i64 32)
  %t1 = bitcast i8* %t0 to %T.Range*
  %t2 = getelementptr inbounds %T.Range, %T.Range* %t1, i32 0, i32 0
  store i64 1, i64* %t2
  %t3 = alloca double
  store double %min, double* %t3
  %t4 = alloca double
  store double %max, double* %t4
  %t5 = load double, double* %t3
  %t6 = getelementptr inbounds %T.Range, %T.Range* %t1, i32 0, i32 1
  store double %t5, double* %t6
  %t7 = load double, double* %t4
  %t8 = getelementptr inbounds %T.Range, %T.Range* %t1, i32 0, i32 2
  store double %t7, double* %t8
  %t9 = load double, double* %t3
  %t10 = fsub double %t9, 1.0e0
  %t11 = getelementptr inbounds %T.Range, %T.Range* %t1, i32 0, i32 3
  store double %t10, double* %t11
  ret i8* %t0
}

define double @Range_next(i8* %self) {
entry:
  %t12 = ptrtoint i8* %self to i64
  %t13 = bitcast i64 %t12 to double
  %t14 = bitcast double %t13 to i64
  %t15 = alloca i64
  store i64 %t14, i64* %t15
  %t16 = load i64, i64* %t15
  %t17 = inttoptr i64 %t16 to i8*
  %t18 = bitcast i8* %t17 to %T.Range*
  %t19 = getelementptr inbounds %T.Range, %T.Range* %t18, i32 0, i32 3
  %t20 = load double, double* %t19
  %t21 = fadd double %t20, 1.0e0
  %t22 = ptrtoint i8* %self to i64
  %t23 = bitcast i64 %t22 to double
  %t24 = bitcast double %t23 to i64
  %t25 = alloca i64
  store i64 %t24, i64* %t25
  %t26 = load i64, i64* %t25
  %t27 = inttoptr i64 %t26 to i8*
  %t28 = bitcast i8* %t27 to %T.Range*
  %t29 = getelementptr inbounds %T.Range, %T.Range* %t28, i32 0, i32 3
  store double %t21, double* %t29
  %t30 = ptrtoint i8* %self to i64
  %t31 = bitcast i64 %t30 to double
  %t32 = bitcast double %t31 to i64
  %t33 = alloca i64
  store i64 %t32, i64* %t33
  %t34 = load i64, i64* %t33
  %t35 = inttoptr i64 %t34 to i8*
  %t36 = bitcast i8* %t35 to %T.Range*
  %t37 = getelementptr inbounds %T.Range, %T.Range* %t36, i32 0, i32 3
  %t38 = load double, double* %t37
  %t39 = ptrtoint i8* %self to i64
  %t40 = bitcast i64 %t39 to double
  %t41 = bitcast double %t40 to i64
  %t42 = alloca i64
  store i64 %t41, i64* %t42
  %t43 = load i64, i64* %t42
  %t44 = inttoptr i64 %t43 to i8*
  %t45 = bitcast i8* %t44 to %T.Range*
  %t46 = getelementptr inbounds %T.Range, %T.Range* %t45, i32 0, i32 2
  %t47 = load double, double* %t46
  %t49 = fcmp olt double %t38, %t47
  %t48 = select i1 %t49, double 1.0, double 0.0
  ret double %t48
}

define double @Range_get_current(i8* %self) {
entry:
  %t50 = ptrtoint i8* %self to i64
  %t51 = bitcast i64 %t50 to double
  %t52 = bitcast double %t51 to i64
  %t53 = alloca i64
  store i64 %t52, i64* %t53
  %t54 = load i64, i64* %t53
  %t55 = inttoptr i64 %t54 to i8*
  %t56 = bitcast i8* %t55 to %T.Range*
  %t57 = getelementptr inbounds %T.Range, %T.Range* %t56, i32 0, i32 3
  %t58 = load double, double* %t57
  ret double %t58
}

define i8* @IsOddWrapper_new() {
entry:
  %t59 = call i8* @malloc(i64 8)
  %t60 = bitcast i8* %t59 to %T.IsOddWrapper*
  %t61 = getelementptr inbounds %T.IsOddWrapper, %T.IsOddWrapper* %t60, i32 0, i32 0
  store i64 2, i64* %t61
  ret i8* %t59
}

define double @IsOddWrapper_invoke(i8* %self, double %x) {
entry:
  %t62 = alloca double
  store double %x, double* %t62
  %t63 = load double, double* %t62
  %t64 = call double @is_odd(double %t63)
  ret double %t64
}

define double @range(double %min, double %max) {
entry:
  %t65 = alloca double
  store double %min, double* %t65
  %t66 = alloca double
  store double %max, double* %t66
  %t67 = load double, double* %t65
  %t68 = load double, double* %t66
  %t69 = call i8* @Range_new(double %t67, double %t68)
  %t70 = ptrtoint i8* %t69 to i64
  %t71 = bitcast i64 %t70 to double
  ret double %t71
}

define double @count_when(double %numbers, double %filter) {
entry:
  %t72 = alloca double
  store double %numbers, double* %t72
  %t73 = alloca double
  store double %filter, double* %t73
  %t74 = alloca double
  store double 0.0e0, double* %t74
  %t75 = load double, double* %t72
  %t76 = alloca double
  store double %t75, double* %t76
  br label %icond_77
icond_77:
  %t80 = load double, double* %t76
  %t81 = bitcast double %t80 to i64
  %t82 = alloca i64
  store i64 %t81, i64* %t82
  %t83 = load i64, i64* %t82
  %t84 = inttoptr i64 %t83 to i8*
  %t85 = call double @Range_next(i8* %t84)
  %t86 = fcmp one double %t85, 0.0
  br i1 %t86, label %ibody_78, label %iend_79
ibody_78:
  %t87 = load double, double* %t76
  %t88 = bitcast double %t87 to i64
  %t89 = alloca i64
  store i64 %t88, i64* %t89
  %t90 = load i64, i64* %t89
  %t91 = inttoptr i64 %t90 to i8*
  %t92 = call double @Range_get_current(i8* %t91)
  %t93 = alloca double
  store double %t92, double* %t93
  %t94 = load double, double* %t74
  %t95 = load double, double* %t93
  %t96 = load double, double* %t73
  %t97 = bitcast double %t96 to i64
  %t98 = alloca i64
  store i64 %t97, i64* %t98
  %t99 = load i64, i64* %t98
  %t100 = inttoptr i64 %t99 to i8*
  %t101 = call double @NumberFilter_dispatch(i8* %t100, double %t95)
  %t102 = fcmp one double %t101, 0.0
  %t103 = alloca double
  br i1 %t102, label %then_104, label %else_105
then_104:
  store double 1.0e0, double* %t103
  br label %merge_106
else_105:
  store double 0.0e0, double* %t103
  br label %merge_106
merge_106:
  %t107 = load double, double* %t103
  %t108 = fadd double %t94, %t107
  store double %t108, double* %t74
  br label %icond_77
iend_79:
  %t109 = load double, double* %t74
  ret double %t109
}

define double @is_odd(double %x) {
entry:
  %t110 = alloca double
  store double %x, double* %t110
  %t111 = load double, double* %t110
  %t112 = frem double %t111, 2.0e0
  %t114 = fcmp oeq double %t112, 0.0e0
  %t113 = select i1 %t114, double 1.0, double 0.0
  ret double %t113
}

define double @NumberFilter_dispatch(i8* %obj, double %arg) {
entry:
  %t115 = bitcast i8* %obj to i64*
  %t116 = load i64, i64* %t115
  %t117 = trunc i64 %t116 to i32
  switch i32 %t117, label %default [
    i32 2, label %case_IsOddWrapper
  ]

case_IsOddWrapper:
  %t118 = call double @IsOddWrapper_invoke(i8* %obj, double %arg)
  ret double %t118

default:
  call void @abort()
  unreachable
}

define i8* @__hulk_num_to_str(double %val) {
entry:
  %fl = call double @llvm.floor.f64(double %val)
  %diff = fsub double %val, %fl
  %is_int = fcmp oeq double %diff, 0.0
  %abs_val = call double @llvm.fabs.f64(double %val)
  %small_enough = fcmp olt double %abs_val, 1.0e15
  %use_int = and i1 %is_int, %small_enough
  br i1 %use_int, label %fmt_as_int, label %fmt_as_dbl
fmt_as_int:
  %ilen = call i32 (i8*, i64, i8*, ...) @snprintf(i8* null, i64 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.fmt_int, i64 0, i64 0), double %val)
  %ilen64 = sext i32 %ilen to i64
  %ibufsz = add i64 %ilen64, 1
  %ibuf = call i8* @malloc(i64 %ibufsz)
  call i32 (i8*, i64, i8*, ...) @snprintf(i8* %ibuf, i64 %ibufsz, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.fmt_int, i64 0, i64 0), double %val)
  ret i8* %ibuf
fmt_as_dbl:
  %dlen = call i32 (i8*, i64, i8*, ...) @snprintf(i8* null, i64 0, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.fmt_num, i64 0, i64 0), double %val)
  %dlen64 = sext i32 %dlen to i64
  %dbufsz = add i64 %dlen64, 1
  %dbuf = call i8* @malloc(i64 %dbufsz)
  call i32 (i8*, i64, i8*, ...) @snprintf(i8* %dbuf, i64 %dbufsz, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.fmt_num, i64 0, i64 0), double %val)
  ret i8* %dbuf
}

define i8* @__hulk_bool_to_str(double %val) {
entry:
  %cond = fcmp one double %val, 0.0
  %res = select i1 %cond, i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.true_s, i64 0, i64 0), i8* getelementptr inbounds ([6 x i8], [6 x i8]* @.false_s, i64 0, i64 0)
  ret i8* %res
}

define void @__hulk_print_val(double %val) {
entry:
  ; Respaldo: imprimir como n√∫mero (por defecto seguro para tipo Unknown)
  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.fmt_num, i64 0, i64 0), double %val)
  call i32 @puts(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.empty_s, i64 0, i64 0))
  ret void
}

define i8* @__hulk_to_str(double %val) {
entry:
  %numstr = call i8* @__hulk_num_to_str(double %val)
  ret i8* %numstr
}

define i32 @main() {
entry:
  %t119 = call double @range(double 0.0e0, double 1.0e2)
  %t120 = alloca double
  store double %t119, double* %t120
  %t121 = load double, double* %t120
  %t122 = call i8* @IsOddWrapper_new()
  %t123 = ptrtoint i8* %t122 to i64
  %t124 = bitcast i64 %t123 to double
  %t125 = call double @count_when(double %t121, double %t124)
  call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([5 x i8], [5 x i8]* @.fmt_num, i64 0, i64 0), double %t125)
  call i32 @puts(i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.empty_s, i64 0, i64 0))
  ret i32 0
}

