def repeat(n: Number, *expr: Object): Object =>
    let cnt = n in
        while (cnt >= 0) {
            cnt := cnt - 1;
            expr;
        };

def swap(@a: Object, @b: Object) {
    let temp: Object = a in {
        a := b;
        b := temp;
    }
}
def simplify(expr:Number) { // Note: 'number' type hint is ignored by macro engine mostly
    match(expr) {
        // --- Boolean Logic ---
        case !(!b1) => simplify(b1);
        case (b1 & true) => simplify(b1);
        case (true & b1) => simplify(b1);
        case (b1 & false) => false;
        case (false & b1) => false;
        case (b1 | true) => true;
        case (true & b1) => true; // Oops typo in description but let's implement 'true | b1'
        case (true | b1) => true;
        case (b1 | false) => simplify(b1);
        case (false | b1) => simplify(b1);

        // --- Distributive Property: a * (b + c) -> ab + ac ---
        case (a * (b + c)) => simplify(a * b) + simplify(a * c);
        case ((b + c) * a) => simplify(b * a) + simplify(c * a);

        // --- Double negation --- 
        case -(-(x)) => simplify(x);

        // --- Zero/One Rules ---
        case (x1 * 0) => 0;
        case (0 * x1) => 0;
        case (x1 + 0) => simplify(x1);
        case (0 + x1) => simplify(x1);
        case (x1 - 0) => simplify(x1);
        case (x1 * 1) => simplify(x1);
        case (1 * x1) => simplify(x1);
        
        // --- Recursive descent ---
        case (x1 + x2) => simplify(x1) + simplify(x2);
        case (x1 - x2) => simplify(x1) - simplify(x2);
        case (x1 * x2) => simplify(x1) * simplify(x2);
        case (b1 & b2) => simplify(b1) & simplify(b2);
        case (b1 | b2) => simplify(b1) | simplify(b2);
        
        default => expr;
    };
}
def repeat2($iter: Number, n: Number, *expr:Object) {
    let iter: Number = 0, total:Number = n in {
        while (total >= 0) {
            total := total - 1;
            expr;
            iter := iter + 1
        };
    }
}

{
print("--- Boolean Simplification ---");
print(simplify(!(!true)));               // true
print(simplify(true & false));           // false
print(simplify(false | (true & true)));  // true

print("--- Distributive Property ---");
// 2 * (3 + 4) -> 2*3 + 2*4 -> 6 + 8 -> 14
print(simplify(2 * (3 + 4))); 
print(simplify((10 + 5) * 2)); 

print("--- Combined Complexity ---");
// 1 * (x + 0) -> 1 * x -> x  (if x is var, we can't test unless x is literal for now in runner)
// But we can test: 1 * (5 + 0) -> 5
print(simplify(1 * (5 + 0)));

print("--- Original Tests ---");
print(simplify(-(-(42))));
print(simplify(0 + 10));

print("--- Functional Macros ---");
repeat(2) {
    print(sqrt(100));
}
}